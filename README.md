# SearchingAlgorithmVisualizer

Binary Search:

![alt text](image.png)



Decompostion:

    First, we initialize by setting up two pointers, left and right and the start and the end of the sorted array respectively.

    Then find the middle index between each pointer.

    Check if the middle element matches the target value.

        If it == the target -> Return index
        If it < the target -> search the right half (move the left pointer.)
        If it > the target -> search left half (move the right pointer)

    Continue until target is found or search space is exhausted


Pattern Recogniton:

    Every step, we compare the middle element with the target. Every time the search space is cut in half. This loop continues while left <= right. Pretty simple to implemment. 

Abstraction:

    Need to show to the viewer the current array behing searched, the current left, middle and right pointer positions and the comparison each step. Also would be nice to see which half of the array is eliminated after each step. 

    We can hide mostly everything else, the actual if-else conditional code, all that jargon. 

Algorithm Design:

    Input: Sorted Array, a user can enter / generate a random list of integers. As well as a target value to search for in the array.

    Processing: Parse then validate the input as an array. Initialize left = 0 & right = length - 1 . And while left <= right: Calculate middle = (left+right) / 2 , compare array[middle] with target, adjust the pointers based off of that. Also log each step for visualization. Return result.

    Output: A visual representation of each iteration. Then a display of the result such as "Target found at index X" or "Target not found" Statistics about the number of comparisons made, demonstrating O logn efficiency. 


Why I chose Binary Search:

    Well, it's efficient, it's intuitive, it's used in many real world applications, has very VERY clear steps and it also looks pretty. There's nothing more satisfying than watching a data set slowly widdle down.

This flowchart demonstrates everything. Generated by Chat : https://chatgpt.com/share/6934d361-00c0-800a-a7e0-59fd11570227

┌──────────────────────────────┐
│        START                 │
│  User Input (Array, Target)  │
└──────────────┬───────────────┘
               │
               ▼
┌──────────────────────────────┐
│  Validate & Parse Input      │
│  (Check if sorted)           │
└──────────────┬───────────────┘
               │
               ▼
┌──────────────────────────────┐
│ Initialize Pointers          │
│ left = 0, right = n - 1      │
└──────────────┬───────────────┘
               │
               ▼
┌──────────────────────────────┐
│ Condition: left ≤ right ?    │
└───────┬───────────┬─────────┘
        │Yes         │No
        ▼             ▼
┌─────────────────┐  ┌────────────────────────┐
│ Calculate mid =  │  │ Target Not Found       │
│ (left + right)/2 │  │ Return -1              │
└────────┬─────────┘  └────────────┬───────────┘
         │                         │
         ▼                         ▼
┌──────────────────────────────┐   │
│ Condition: array[mid] ==     │   │
│ target ?                     │   │
└───────┬───────────┬─────────┘   │
        │Yes         │No           │
        ▼             ▼            │
┌──────────────────────────────┐   │
│ Target Found! Return index   │   │
└──────────────┬───────────────┘   │
               │                   │
               ▼                   │
┌──────────────────────────────┐   │
│ Condition: array[mid] <      │   │
│ target ?                     │   │
└───────┬───────────┬─────────┘   │
        │Yes         │No           │
        ▼             ▼            │
┌──────────────────┐  ┌──────────────────┐
│ Set left = mid+1 │  │ Set right=mid-1 │
└────────┬─────────┘  └────────┬────────┘
         │                     │
         └──────────┬──────────┘
                    ▼
          (Loop back to "left ≤ right?")
               ▲
               │
               │
┌──────────────┴───────────────┐
│             END               │
│        Display Result         │
└──────────────────────────────┘



Running is quite simple. Just enter in a series of ascending integers and a target, or use the premade integer list.


https://huggingface.co/spaces/ItsmeMaxim/CISC121-Project




Created By Maxim Cameron
Agknowledgement:
Because Gradio is a new library to me, I heavily read from the wikipage (Linked inside the code) for a lot parts of my code.
Especially with the block system I read exactly off of it.

For AI usage, I used Claude to brainstorm ideas (especially for HOW I was going to show the steps)
I used CoPilot to fix most errors and used it's auto fill feature for time
I used ChatGPT a few times as well (with the second last line in app.py.)